# java基础

**1.java都有哪些数据类型？分别占多少字节？多少位？**

| 数据类型 | 字节数 | bit位 | 作用                                                         |
| -------- | ------ | ----- | ------------------------------------------------------------ |
| byte     | 1      | 8     | 用于存储较小的整数值，范围是从 -128 到 127。                 |
| short    | 2      | 16    | 用于存储较大一些的整数值，范围是从 -32,768 到 32,767。       |
| int      | 4      | 32    | 用于存储标准整数值，范围是从 -2^31 到 2^31 - 1。             |
| long     | 8      | 64    | 用于存储非常大的整数值，范围是从 -2^63 到 2^63 - 1。         |
| float    | 4      | 32    | 用于存储单精度浮点数。                                       |
| double   | 8      | 64    | 用于存储双精度浮点数，这是 Java 中默认的浮点数类型。         |
| char     | 2      | 16    | 用于存储单个字符，使用的是 Unicode 编码表，范围是从 '\u0000' 到 '\uffff'，即从 0 到 65,535。 |
| boolean  | 1      | 8     | 不占用固定字节数，因为它的大小不是固定的，取决于 JVM 的实现。但是它只存储两个值：true 或 false。 |

**2.Java语言的几大特性是什么？**

**封装：**封装就剩把对象的属性和行为看作一个整体，尽可能的隐藏内部的细节，只把可以告诉别人的公开，别人可以用我提供的功能实现需求，但不知道怎么实现的，提高了安全性。

**继承：**子类继承父类的属性和行为，并可以根据自己的需求扩展自己的行为，这样提高了代码的复用性。

**多态：**出现在父类指向子类中，允许不同的对象对同一消息做出响应，就是同一个消息根据发送对象的不同，采用不同的行为方式。

**抽象：**表示对问题领域进行分析，设计中得出抽象的概念，是对一系列看上去不同，但本质上相同的具体概念的抽象。在java中抽象用abstract关键字来修饰，使用abstract修饰类时，此类就不能被实例化，从这里可以看出，抽象类（接口）就是为了继承而存在的。

**3.java权限修饰符**

**default(默认的)：**default就是不写任何关键字，它可以修饰类、成员变量、成员方法、构造方法。被默认权限修饰符修饰后只能被本类以及同包下的其他类访问。

**public(公共的)：**public是权限最大的修饰符，他可以修饰类、成员变量、成员方法、构造方法。被public修饰后，可以被任何一个类中、不管同不同包，任意使用。

**private(私有的)：**private可以修饰成员变量、成员方法，构造方法。不能修饰类（这里指的是外部类，内部类不考虑）。被private修饰的成员只能在其修饰的本来中访问，在其他类中不能被调用，但是被private修饰的成员方法可以通过set和get方法向外界提供访问方式。

**protected(受保护的)：**protected可以修饰成员变量、成员方法、构造方法，但不能修饰类（这里指的是外部类）。被protected修饰后，只能被同包下的其他类访问。如果不同包下的类要访问的话，必须是他的子类。

**4.final关键字能加在哪些地方？分别表示什么？**

**final 类：**如果一个类被声明为 `final`，那么这个类不能被继承。这意味这不能有其他类作为该类的子类。

**final方法：**当方法被声明为`final`时，他不能被子类重写（override）。这通常用于防止子类改变方法的行为，确保某些功能保持不变。

**final 变量：**

当变量被声明为`final`时，一旦赋值就不能再改变了。对于基本数据类型，这意味着他的值是不可变的；对于对象引用，这意味这引用本身不能指向另一个对象，但是对象自身的状态是可以改变的（除非对象本身也是不可变的）

如果`final`修饰的的是实列变量，则必须在构造函数或构造块中初始化；如果`final`修饰的是静态变量，则必须在静态初始化块中或者声明时初始化。

**final 参数：**在方法签名中，参数可以被声明为`final`,表示该参数在方法体内不能被重新赋值。

**局部 final：**在代码块、循环、try-with-resources 中声明的局部变量也可以使用`final`关键字，限制其不能再被赋新值。

**匿名内部类：**再java 8 之前，如果在匿名内部类中使用局部变量，那么这些变量必须被显式地声明为`final`。从java 8开始，编译器允许局部变量具有“实际上的最终性”（effectively final）,即只要他们在作用域内没有被重新赋值就可以在匿名内部类中使用，即使不显式声明为`final`。

**5.static关键字能加在哪些地方？分别代表什么？**

**静态变量（类变量）：**当变量被声明为`static`时，它属于类而不是类的实例。这意味着所有该类的实例共享同一个静态变量。静态变量只会在类首次加载时初始化一次，并且可以通过类名直接访问，无需创建类的实例。

**静态方法：**当方法被声明为`static`时，这个方法也属于类本身而不是类的实例。静态方法可以直接通过类名调用，而不需要创建对象。静态方法只能访问静态成员（静态变量跟其他静态方法），因为他们不依赖任何特定的实例状态。

**静态代码块（静态初始化块）：**静态块是用于初始化静态变量的一段代码。它会在类加载时自动执行，而不是只会执行一次。多个静态代码块会按照他们在代码中的顺序依次执行。

**静态内部类：**静态内部类（也称为嵌套类）是定义在另一个类中的类，并且带有`static`修饰符。它可以像普通顶级类一样自由创建和使用，因为它不依赖于外部的实例。静态内部类不能直接访问外部类的非静态成员，但可以访问外部类的静态成员。

**静态导入：**虽然不是`static`关键字的直接应用，但静态导入允许导入某个类或接口中的静态成员（方法或字段），从而可以在不使用类名的情况下直接引入这些成员。这通常用于频繁使用的静态方法或常量，以简化代码书写。

**6.重写跟重载**

**重写：**`重写`发生在子父类中，方法名、参数类型、返回值必须相同，返回值的范围小于等于父类，抛出的异常范围小于等于父类，访问的修饰符大于等于父类，如果父类被private修饰，则不能被重写。

**重载：**`重载`发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同、返回值不同和修饰符可以不同。

**7.接口中可以有哪些成员？抽象类呢？接口和抽象类又有什么区别？**

**注意：**JDK1.8接口中是可以出现非抽象方法的：default方法、静态方法

|            | 接口       | 抽象类  |
| ---------- | ---------- | ------- |
| 关键字     | implements | extends |
| 个数       | 不限       | 1个     |
| 构造函数   | 无         | 有      |
| main方法   | 无         | 有      |
| 访问修饰符 | 默认public | 任意    |

**8.== 和 equals的异同**

**相同点**

- 两者都可以用来进行某种形式的相等性比较。

**不同点**

1. **比较的对象/类型**：
   - `==`：对于基本数据类型（如 `int`, `char`, `float` 等），它直接比较两个值是否相等；对于引用类型（即对象），它比较的是两个对象的内存地址（引用）是否相同。
   - `equals()`：这是 `Object` 类中的一个方法，默认情况下它的行为与 `==` 对于引用类型是相同的，但是很多类（如 `String`, `Integer`, `Double` 等）都重写了这个方法来提供基于内容的比较。
2. **比较的内容**：
   - `==`：如上所述，对于引用类型，它检查的是两个引用是否指向同一个对象实例。
   - `equals()`：如果该方法被适当重写，它可以用来比较两个对象的内容是否相等。例如，对于 `String` 类，`equals()` 比较的是字符串的实际字符序列，而不是它们的引用。
3. **性能**：
   - `==`：通常比调用 `equals()` 更快，因为它只是简单地比较两个数值或者两个引用是否相等。
   - `equals()`：可能涉及更多的计算，特别是当涉及到复杂对象的比较时，这可能会导致性能开销。
4. **适用场景**：
   - `==`：适用于需要比较两个基本数据类型的值，或是需要确定两个引用是否指向同一个对象时。
   - `equals()`：当需要根据对象的内部状态或内容来进行逻辑上的相等性判断时使用。
5. **空指针处理**：
   - `==`：可以安全地应用于 `null` 值，因为它是简单的引用比较。
   - `equals()`：如果不小心将 `null` 传递给 `equals()` 方法，会导致 `NullPointerException`。因此，在调用 `equals()` 之前，通常应该先检查对象是否为 `null`。

## java异常体系

Java异常体系结构图

![java异常体系](\img\abnormal_system.png)

异常体系：**Thorwable**类（表示可抛出）是所有异常和错误的超类，两个直接子类为**Error**和**Exception**，分别表示错误和异常。其中异常类Exception又分为**运行时异常(RuntimeException)**和**非运行时异常**， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。

1、**Error错误：**（这种错误无法处理）描述了Java运行时系统的内部错误和资源耗尽错误。一般是指虚拟机（JVM）相关的问题，如系统崩溃，虚拟机出错误等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常不处理。因为如果出现这样的内部错误，除了通告用户，并尽力使程序安全地终止之外，再也无能为力了。

2、**Exception异常：**Java的异常分为两种，`checked Exception`（编译时异常也叫非运行时异常）和 `RuntimeException`（运行时异常）。

​		a.**运行时异常**（逻辑方面）都是`RuntimeException`类及其子类异常，如`NullPointerException`、`IndexOutOfBoundsException`等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

​		b.**非运行时异常**（程序语法）是`RuntimeException`以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如`IOException`、`SQLException`等以及用户自定义的Exception异常，一般情况下不自定义检查异常。

## java集合体系